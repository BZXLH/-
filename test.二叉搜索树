#include<bits/stdc++.h>
using namespace std;

class SerchTree{
private:
	TreeNode* root;
public:
	SerchTree();

	//插入节点
	void Insert_Node(TreeNode* root,int val)
	{
		if(NULL == root)
			root = new TreeNode(val);
		else
		{
			if(val<root->val)
				Insert_Node(root->left,val);
			else
				Insert_Node(root->right,val);
		}
	}

	//从数组中构造二叉搜索树	
	void Create_SerchTree(vector<int>& vec)
	{
		int sz = vec.size();
		for(int i = 0;i<sz;i++
			Insert_Node(root,vec[i]);
	}

	//搜索某个节点是否存在
	bool SerchNode(TreeNode* root,int val)
	{
		if(NULL == root)
			return false;
		if(val<root->val)
			return SerchNode(root->left,val);
		else if(val>root->val)
			return SerchNode(root->right)
		else
			return ture;
	}
	
	//删除节点
	void DelNode(TreeNode* node)
	{
		TreeNode* temp;
		if(NULL == node->right)
		{
			temp = node;
			node = node->left;
			delete temp;
		}
		else
		{
			temp = node;
			while(NULL != temp->left)
				temp = temp->left;
			node->val = temp->val;
			delete temp;
		}
	}	
	//删除某个节点
	void DelSerchNode(TreeNode* root,int val)
	{
		if(NULL == root)
			return;
		if(val<root->val)
			return DelSerchNode(root->left,val);
		else if(val>root->val)
			return DelSerchNode(root->right)
		else
			DelNode(root);
	}

	//计算二叉树的最大深度
	int maxDepth(Node x) 
	{
		if (x == null) 
			return 0; 
		
		int max = 0; 
		int maxL = 0; 
		int maxR = 0;  
		if (x.left != null)  
			maxL = maxDepth(x.left); 
		if (x.right != null)
			maxR = maxDepth(x.right); 
		max = maxL > maxR ? maxL + 1 : maxR + 1; return max; 
	}
}
